---
title: 单元测试&持续集成
date: 2018-10-15 15:56:09
categories: [Vue]
tags: [Vue,单元测试,持续集成,TDD]
---

## 一、测试工具介绍

- 这里使用Karma + Mocha做单元测试，TravisCI做持续集成
- Karma（[ˈkɑrmə] 卡玛）是一个测试运行器，它可以呼起浏览器，加载测试脚本，然后运行测试用例
- Mocha（[ˈmoʊkə] 摩卡）是一个单元测试框架/库，它可以用来写测试用例
- Sinon（西农）是一个 spy / stub / mock 库，用以辅助测试

除此之外了解两个词语：
- BDD 行为驱动开发  Behavior Driven Development
- TDD 测试驱动开发 Test Driven Development

## 二、步骤

### 1、安装各种工具

- 注意：如果一个包给用户用就不要-D，-D是给开发者用的

```
npm install -D karma karma-chrome-launcher karma-mocha karma-sinon-chai mocha sinon sinon-chai karma-chai karma-chai-spies
npm install chai -D
npm install chai-spies
```

### 2、创建karma 配置

- frameworks引入'mocha', 就会拥有descibe it函数
- frameworks引入'sinon-chai'，就会有sinon.fake()，expect函数
- files 检索 dist文件里所有的test.js文件和test.css文件
- browsers 使用的是ChromeHeadless

```
// 根目录创 karma.conf.js，内容如下

 module.exports = function (config) {
     config.set({

         // base path that will be used to resolve all patterns (eg. files, exclude)
         basePath: '',
            // frameworks to use
            // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
            frameworks: ['mocha', 'sinon-chai'],
            client: {
                chai: {
                    includeStack: true
                }
            },

            // list of files / patterns to load in the browser
            files: [
                'dist/**/*.test.js',
                'dist/**/*.test.css'
            ],


            // list of files / patterns to exclude
            exclude: [],


            // preprocess matching files before serving them to the browser
            // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
            preprocessors: {},


            // test results reporter to use
            // possible values: 'dots', 'progress'
            // available reporters: https://npmjs.org/browse/keyword/karma-reporter
            reporters: ['progress'],


            // web server port
            port: 9876,


            // enable / disable colors in the output (reporters and logs)
            colors: true,


            // level of logging
            // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
            logLevel: config.LOG_INFO,


            // enable / disable watching file and executing tests whenever any file changes
            autoWatch: true,


            // start these browsers
            // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher
            browsers: ['ChromeHeadless'],


            // Continuous Integration mode
            // if true, Karma captures browsers, runs the tests and exits
            singleRun: false,

            // Concurrency level
            // how many browser should be started simultaneous
            concurrency: Infinity
        })
    }
```


### 3、创建测试用例

- 举例：根目录下test/button.test.js

- 声明expect、引入Vue、引入Button组件

```
const expect = chai.expect;
import Vue from 'vue'
import Button from '../src/button'

Vue.config.productionTip = false;
Vue.config.devtools = false;
```

- 测试用例

```
表示对Button这个组件进行描述
1、它存在，所以我断言它存在expect(Button).to.be.ok。
2、它可以设置icon，所以我创建一个Button组件并且传入一个icon值，找到use元素，我断言use的一个属性值为#i-settings。
3、它被点击可以触发事件，所以我创建Button设置icon后，我断言sinon.fake()会被调用，因为sinon.fake()知道自己是否被调用。

describe('Button', () => {
    // BDD 行为驱动测试
    it('存在.', () => {
        expect(Button).to.be.ok
    });

    it('可以设置icon.', () => {
    const Constructor = Vue.extend(Button);
    const vm = new Constructor({
        propsData: {
            icon: 'settings'
        }
    }).$mount();
    const useElement = vm.$el.querySelector('use');
    expect(useElement.getAttribute('xlink:href')).to.equal('#i-settings');
    vm.$destroy()
    });

    it('点击 button 触发 click 事件', () => {
    const Constructor = Vue.extend(Button);
    const vm = new Constructor({
        propsData: {
            icon: 'settings',
        }
    }).$mount();
    const callback = sinon.fake();//fake可以知道自己是否被调用
    vm.$on('click', callback);
    vm.$el.click();
    expect(callback).to.have.been.called
})
})
```

- 文件代码如下：

```
const expect = chai.expect;
import Vue from 'vue'
import Button from '../src/button'

Vue.config.productionTip = false;
Vue.config.devtools = false;

describe('Button', () => {
    // BDD 行为驱动测试
    it('存在.', () => {
        expect(Button).to.be.ok
    });

    it('可以设置icon.', () => {
        const Constructor = Vue.extend(Button);
        const vm = new Constructor({
            propsData: {
                icon: 'settings'
            }
        }).$mount();
        const useElement = vm.$el.querySelector('use');
        expect(useElement.getAttribute('xlink:href')).to.equal('#i-settings');
        vm.$destroy()
    });

    it('可以设置loading.', () => {
        const Constructor = Vue.extend(Button);
        const vm = new Constructor({
            propsData: {
                icon: 'settings',
                loading: true
            }
        }).$mount();
        const useElements = vm.$el.querySelectorAll('use');
        expect(useElements.length).to.equal(1);
        expect(useElements[0].getAttribute('xlink:href')).to.equal('#i-loading');
        vm.$destroy()
    });

    it('icon 默认的 order 是 1', () => {
        const div = document.createElement('div');
        document.body.appendChild(div);
        const Constructor = Vue.extend(Button);
        const vm = new Constructor({
            propsData: {
                icon: 'settings',
            }
        }).$mount(div);
        const icon = vm.$el.querySelector('svg');
        expect(getComputedStyle(icon).order).to.eq('1');
        vm.$el.remove();
        vm.$destroy()
    });

    it('设置 iconPosition 可以改变 order', () => {
        const div = document.createElement('div');
        document.body.appendChild(div);
        const Constructor = Vue.extend(Button);
        const vm = new Constructor({
            propsData: {
                icon: 'settings',
                iconPosition: 'right'
            }
        }).$mount(div);
        const icon = vm.$el.querySelector('svg');
        expect(getComputedStyle(icon).order).to.eq('2');
        vm.$el.remove();
        vm.$destroy()
    });

    it('点击 button 触发 click 事件', () => {
        const Constructor = Vue.extend(Button);
        const vm = new Constructor({
            propsData: {
                icon: 'settings',
            }
        }).$mount();
        const callback = sinon.fake();//fake可以知道自己是否被调用
        vm.$on('click', callback);
        vm.$el.click();
        expect(callback).to.have.been.called
    })
});
```

### 4、运行测试用例

- 打开package.json，添加scripts
- 注意这里需要安装parcel后可使用，代码如下：

```
  "scripts": {
    "start": "parcel index.html --no-cache",
    "dev-test": "parcel watch test/* --no-cache & karma start",
    "test": "parcel build test/* --no-cache --no-minify && karma start --single-run"
  }
```

- 运行

```
npm run test
```

## 三、TravisCI 持续集成

- 每次都需要输入npm run test来测试，如果用TravisCI写好测试用例文件配置相关配置就会自动化测试。
- 阮一峰文章：http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html
- 在根目录下配置.travis.yml文件

```
//nodejs环境，版本为8，选用稳定版本的chrome测试
language: node_js
node_js:
  - "8"
addons:
    chrome: stable
sudo: required
before_script:
  - "sudo chown root /opt/google/chrome/chrome-sandbox"
  - "sudo chmod 4755 /opt/google/chrome/chrome-sandbox"
```

- 使用github登录官网：https://travis-ci.org/
- 选中测试项目，且测试项目需要有测试脚本
- 每次github提交代码都会进行测试